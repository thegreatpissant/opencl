#+OPTIONS: ^:{}

James A. Feister, OpenCL Notebook

* Intro
  This is my notebook for OpenCL.  It contains a collection of notes
  from various resources.  Some of these are taken verbatim from the
  texts so this should not be taken as my own work.

  Though I tried my best to stick to the text it can become trying and
  repetive to reproduce information that is already available in some
  form or another, and possibly more up to date. Always refer to the
  Reference Pages [fn:2] for the most thurough and up to date information.
  
  References include:
  - OpenCL in action[fn:1]: How to Accelerate Graphics and Computation
  - OpenCL 1.0 Reference Pages [fn:2] 

  The hardest or most tedious part is setting up the context and
  managing the resources.  This involves identifying the devices,
  making sure you program can run and then what, how, and when your
  resources allocated will run your program.  

  Its not easy but what is.  Could it be easier???  Maybe but this is
  not a hello world example.  This is a semi-begin er to intermediate
  intro to advanced topics.  Stick with it.
    

* About OpenCL
  OpenCL allows for utilizing different VECTOR processing units while
  remaining manufacture agnostic.  You can use Intel, AMD, NVIDIA, or
  other hardware vector processing capabilities without having to know
  their specific implementations.
  
  Typical applications of vector processing for the purpose of OpenCL
  are broken into one of 3 categories.
  - Physical or Geometric: Vectors that represent Magnitude and
  Direction
  - Mathematical vector: Ordered one dimensional collection of
    elements
  - Computational: Data structure that contains multiple elements of
  the same data type.


* Data Structures
  There are six basic data structures of OpenCL

  1) Platforms: Identifies a Vendors implementation

  2) Devices
     
  3) Contexts
     
  4) Programs
     
  5) Kernels
     
  6) Command Queues
     

* Primitive Data Types
  
  Table \ref{table:1} shows a list of all primitive OpenCL data types found in CL/cl_platform.h

#+CAPTION: OpenCL Primitive Data types
#+LABEL: table:1  
  | Scalar Data Type | Bit Width | Purpose                               |
  |------------------+-----------+---------------------------------------|
  | cl_char          |         8 | Signed two's Complement integer       |
  | cl_uchar         |         8 | unSigned two's complement integer     |
  | cl_short         |        16 | Signed two's Complement integer       |
  | cl_ushort        |        16 | unSigned two's Complement integer     |
  | cl_int           |        32 | Signed two's Complement integer       |
  | cl_uint          |        32 | unSigned two's Complement integer     |
  | cl_long          |        64 | Signed two's Complement integer       |
  | cl_ulong         |        64 | unSigned two's Complement integer     |
  | cl_half          |        16 | Half precision floating point value |
  | cl_float         |        32 | Single precision floating point value |
  | cl_double        |        64 | Double precision floating point value |
  |------------------+-----------+---------------------------------------|
  

* Platform Data Structure
  
  type: cl_platform_id - represents a platform of a OpenCL
  implementation
  
  For example if you have a NVIDIA video card and Intel CPU, you would
  require two platforms, one to access the NVIDIA CUDA video card
  platform and one to access the Intel SMD

** Obtaining available platforms
   Platforms are only available if you have the appropriate vendor SDK
   installed on your system.
   
   Function def: 
#+BEGIN_SRC c
  cl_int clGetPlatformIDs (cl_uint num_entries, 
                           cl_platform_id * platforms, 
                           cl_uint * num_platforms);
#+END_SRC

   
   The clGetPlatformIDs function allows for you to query the number of
   available platforms.
   
   #+begin_src c
     cl_int num_platforms; 
     clGetPlatformIDs (1, NULL, &num_platforms);
   #+end_src
   
   You then can use it to obtain handles to those platforms.  Which
   allow you to query for information on them.
   
   #+begin_src c
     cl_platform_id platforms = (platforms *) malloc ( sizeof (cl_platform_id) * num_platforms ); 
     
     clGetPlatformIDs (num_platforms, platforms, NULL);
   #+end_src
   
   You now have handles to all platforms available on your system.
   
   
** Obtaining platform information
   Table \ref{table:2} Shows all information about a platform may be queried.
   
#+CAPTION: Platform query information
#+LABEL:  table:2
   | Parameter name         | Purpose                                          |
   |------------------------+--------------------------------------------------|
   | CL_PLATFORM_NAME       | Name of the platform                             |
   | CL_PLATFORM_VENDOR     | Vendor of the platform                           |
   | CL_PLATFORM_VERSION    | Supported  OpenCL version                        |
   | CL_PLATFORM_PROFILE    | FULL_PROFILE or EMBEDDED_PROFILE OpenCL Standard |
   | CL_PLATFORM_EXTENSIONS | List of supported extensions                     |
   |------------------------+--------------------------------------------------|
   
   The function clGetPlatformInfo function is used to query for this
   information.
   
   #+begin_src c
     cl_int clGetPlatformInfo(cl_platform_id platform, 
                              cl_platform_info param_name, 
                              size_t param_value_size, 
                              void *param_value, 
                              size_t *param_value_size_ret);
   #+end_src
   
   The following user created support functions will query for all
   platforms parameter values. Pass the platform to
   sb_clPrintPlatformInfo to print all platform values.
   
   #+begin_src c
  void sb_clPrintPlatformInfo ( cl_platform_id * platform ) 
  {
    printf ("Platform Info\n");
  
    printf ("\tName: ");
    sb_clPrintPlatformExtension ( platform, CL_PLATFORM_NAME );
    printf ("\n");
  
    printf ("\tVendor: ");
    sb_clPrintPlatformExtension (  platform, CL_PLATFORM_VENDOR );
    printf ("\n");
  
    printf ("\tVersion: ");
    sb_clPrintPlatformExtension (  platform, CL_PLATFORM_VERSION );
    printf ("\n");
  
    printf ("\tProfile: ");
    sb_clPrintPlatformExtension (  platform, CL_PLATFORM_PROFILE );
    printf ("\n");
  
    printf ("\tExtensions: ");
    sb_clPrintPlatformExtension (  platform, CL_PLATFORM_EXTENSIONS );
    printf ("\n");
  }
  
  void sb_clPrintPlatformExtension ( cl_platform_id * platform, cl_int extension ) 
  {
    cl_char * ext_data;
    size_t param_size;
    cl_int ret;
  
    ret = clGetPlatformInfo (*platform, extension, 0, NULL, &param_size);
    if ( ret < 0 ) {
      perror ("Couldn't read extension data.");
      exit (EXIT_FAILURE);
    }
    ext_data = (cl_char*)malloc(param_size+1);
    ext_data[param_size] = '\0';
    ret = clGetPlatformInfo (*platform, extension, param_size, ext_data, NULL);
    printf ("%s", ext_data);
    free (ext_data);
  }
   #+end_src
   
   
** Obtaining Devices
   Devices associated with a specific platform can be queried by the
   following function.
   
   #+begin_src c
  cl_int clGetDeviceIDs(cl_platform_id platform,
      cl_device_type device_type, cl_uint num_entries,
      cl_device_id *devices, cl_uint *num_devices)
   #+end_src
   
   Just like the you did with the clGetPlatformIDs function you query a
   platform for the number of devices available of a specific
   type. Then allocate and request device types for that number of
   devices specified.
   
   Table \ref{table:3} shows available devices to query for are in the following table.
   
#+CAPTION: Available device types
#+LABEL: table:3
   | Device type                | Description                  |
   |----------------------------+------------------------------|
   | CL_DEVICE_TYPE_ALL         | All platform devices         |
   | CL_DEVICE_TYPE_DEFAULT     | All platform default devices |
   | CL_DEVICE_TYPE_CPU         | Host processor               |
   | CL_DEVICE_TYPE_GPU         | Device containing a GPU        |
   | CL_DEVICE_TYPE_ACCELERATOR | External accelerator device  |
   |----------------------------+------------------------------|
   
   The following function demonstrates the query for all specific devices on a
   platform.
   
   #+begin_src c
void sb_clPrintPlatformDevices ( cl_platform_id * platform )
{
  cl_uint num_devices;

  //  Get CL_DEVICE_TYPE_ALL for the platform
  clGetDeviceIDs (*platform, CL_DEVICE_TYPE_ALL, 1, NULL, &num_devices);
  printf ("ALL platform devices: %d\n", num_devices);

  // Get  CL_DEVICE_TYPE_DEFAULT for the platform
  clGetDeviceIDs (*platform, CL_DEVICE_TYPE_DEFAULT, 1, NULL, &num_devices);
  printf ("DEFAULT platform devices: %d\n", num_devices);

  // Get  CL_DEVICE_TYPE_CPU for the platform
  clGetDeviceIDs (*platform,  CL_DEVICE_TYPE_CPU, 1, NULL, &num_devices);
  printf ("CPU platform devices: %d\n", num_devices);

  // Get  CL_DEVICE_TYPE_GPU for the platform
  clGetDeviceIDs (*platform,  CL_DEVICE_TYPE_GPU, 1, NULL, &num_devices);
  printf ("GPU platform devices: %d\n", num_devices);

  // Get  CL_DEVICE_TYPE_ACCELERATOR for the platform
  clGetDeviceIDs (*platform,  CL_DEVICE_TYPE_ACCELERATOR, 1, NULL, &num_devices);
  printf ("ACCELERATOR platform devices: %d\n", num_devices);
}
   #+end_src
   
** TODO Obtaining Device Info
   This function does not work as the last, it seems to not return
   the size of the data structure to allocate against it.  Will
   revisit in the future to resolve the shortcuts in this function.
   
   Just as with the platforms you can query devices for their information
   as well.  Table \ref{table:4} list the available fields for query.
   
#+CAPTION: Device query information
#+LABEL: table:4
   | Parameter name               | Output Type | Purpose                                     |
   |------------------------------+-------------+---------------------------------------------|
   | CL_DEVICE_NAME               | char[]      | Name of device                              |
   | CL_DEVICE_VENDOR             | char[]      | Device vendor                               |
   | CL_DEVICE_EXTENSIONS         | char[]      | Supported OpenCL extensions                 |
   | CL_DEVICE_GLOBAL_MEM_SIZE    | cl_ulong    | Size of devices global memory               |
   | CL_DEVICE_ADDRESS_BITS       | cl_uint     | Size of devices address space               |
   | CL_DEVICE_AVAILABLE          | cl_bool     | Is the device available                     |
   | CL_DEVICE_COMPILER_AVAILABLE | cl_bool     | Does the implementation provide a compiler? |
   |------------------------------+-------------+---------------------------------------------|
   
   The clGetDeviceInfo is used to query for device information
   
   #+begin_src c
  cl_int clGetDeviceInfo (cl_device_id device, cl_device_info
  param_name, size_t param_value_size, void *param_value, size_t
  *param_value_size_ret);
   #+end_src
   
   This is a helper function to do the query for these parameters.
   
   #+begin_src c
void sb_clPrintPlatformDeviceInfo ( cl_device_id * device )
{

  size_t   qstring_len = 2048;
  cl_ulong qmemory_size = 0;
  cl_uint  qaddress_space = 0;
  cl_bool  qdevice_available = false;
  cl_bool  qdevice_compiler  = false;
  cl_char * qstring = (cl_char *) malloc (qstring_len+1);

  qstring[qstring_len] = '\0';

  clGetDeviceInfo ( *device, CL_DEVICE_NAME, qstring_len, qstring, NULL);
  printf ("Vendor Device Name: %s\n", qstring);

  clGetDeviceInfo ( *device, CL_DEVICE_VENDOR, qstring_len, qstring, NULL);
  printf ("Vendor Name: %s\n", qstring);

  clGetDeviceInfo ( *device, CL_DEVICE_EXTENSIONS, qstring_len, qstring, NULL);
  printf ("Device Extensions: %s\n", qstring);

  clGetDeviceInfo ( *device, CL_DEVICE_GLOBAL_MEM_SIZE, sizeof (cl_ulong), &qmemory_size, NULL);
  printf ("Device Address Space Size: %d\n", qmemory_size);

  clGetDeviceInfo ( *device, CL_DEVICE_ADDRESS_BITS, sizeof (cl_uint), &qaddress_space, NULL);
  printf ("Device Address Bits: %d\n", qaddress_space);

  clGetDeviceInfo ( *device, CL_DEVICE_AVAILABLE, sizeof (cl_bool), &qdevice_available, NULL);
  printf ("Device Available: %s\n", qdevice_available ? "true":"false");

  clGetDeviceInfo ( *device, CL_DEVICE_COMPILER_AVAILABLE, sizeof (cl_bool), &qdevice_compiler, NULL);
  printf ("Device Compiler: %s\n", qdevice_compiler ? "true":"false");
}
   #+end_src
   
   There are plenty more things to query for as per the standard.
   http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clGetDeviceInfo.html


* Contexts

  Contexts are created to manage devices from the same platform
  selected to work together.  You use the context to create command
  queues for sending kernels to devices.

  An application may use multiple contexts to utilize multiple
  platforms for all devices of each platform.

** Creating

   To populate the cl_context data structure you can grab contexts to selected
   devices or devices of a specific type.

   #+BEGIN_SRC c
     cl_context clCreateContext (const cl_context_properties *properties, 
                                 cl_uint num_devices, const cl_device_id *devices, 
                                 (void CL_CALLBACK *pfn_notify) (const char *errinfo, 
                                                                 const void *private_info, 
                                                                 size_t cb, void *user_data), 
                                 void *user_data, cl_int *errcode_ret);
     
     cl_context clCreateContextFromType (const cl_context_properties *properties,
                                         cl_device_type device_type,
                                         (void CL_CALLBACK *pfn_notify) (const char *errinfo, 
                                                                         const void *private_info, 
                                                                         size_t cb, void *user_data), 
                                         void *user_data, cl_int *errcode_ret);
   #+END_SRC

   Table \ref{table:3} shows all the device types you are able to request.
   =clCreateContext= is used to request user specific devices while
   =clCreateContextFromType= performs a blanket request from a context of the
   specified type.

   Section 2.4.1 creating contexts in the book [fn:1] has a better explanation
   of this process.  I will try my best here.

** Specify the Context =*properties= array

  Table \ref{table:5} shows the available properties you can query for in a
  context. 

  #+CAPTION: Context Property Parameters
  #+LABEL: table:5
  | Property name               | Property value   | Meaning                                                        |
  |-----------------------------+------------------+----------------------------------------------------------------|
  | CL_CONTEXT_PLATFORM         | cl_context_id    | Associates the context with the given platform                 |
  | CL_CONTEXT_D3D10_DEVICE_KHR | ID3D10Device*    | Associates the context with the Direct3D device                |
  | CL_GL_CONTEXT_KHR           | OS-Dependent     | Identifies an OpenGL context                                   |
  | CL_EGL_DISPLAY_KHR          | EGLDisplay       | Displays the OpenGL-ES context on embedded devices             |
  | CL_GLX_DISPLAY_KHR          | GLXContext       | Displays the OpenGL context on Linux                           |
  | CL_WGL_HDC_KHR              | HDC              | Serves as the device context for the OpenGL context on Windows |
  | CL_CGL_SHAREGROUP_KHR       | CGLShareGroupObj | Serves as the share group for the OpenGL context on Mac OS     |
  |-----------------------------+------------------+----------------------------------------------------------------|

  These are used as a *NULL* or *0* terminated array. For example

  #+BEGIN_SRC c  
    cl_context_properties r_context_properties[] = {
      CL_CONTEXT_PLATFORM, (cl_context_properties)platforms[0],
      CL_GL_CONTEXT, (cl_context_properties) glxGetCurrentContext(),
      CL_GLX_DISPLAY_KHR, (cl_context_properties) glxGetCurrentDisplay(),
      0};
  #+END_SRC

  Will query for a context of =platform[0]=, associate the current =GLXContext=
  returned from =glxGetCurrentContext()=, associate the current =Display=
  returned from =glxGetCurrentDisplay()=, and then the last field terminates
  the array with a 0.

  
** Return function

   The =void CL_CALLBACK *notify_func= is a callback function called when an
   error occurs.  This may also be =NULL= to unset its use.

** =*user_data=
   Supplied by the user for use in the context.  On an error this will also be passed to the
   registered callback function.  Its type can be anything from char to int or NULL.

** =*errcode_ret=
   Is the error code returned from creating the context.  

   * CL_INVALID_PLATFORM 'if properties is NULL and no platform could be
     selected or if platform value specified in properties is not a valid
     platform.'

   * CL_INVALID_VALUE 'if context property name in properties is not a
     supported property name; if devices is NULL; if num_devices is equal to
     zero; or if pfn_notify is NULL but user_data is not NULL.'

   * CL_INVALID_DEVICE 'if devices contains an invalid device or are not
     associated with the specified platform.'

   * CL_DEVICE_NOT_AVAILABLE ' if a device in devices is currently not
     available even though the device was returned by clGetDeviceIDs.'

   * CL_OUT_OF_HOST_MEMORY 'if there is a failure to allocate resources
     required by the OpenCL implementation on the host.'

** Context request
   After reading the above and the book [fn:1] we come up with the following
   example piece of code.  This will use the =context_props= context type
   request array from before with a type of GPU and exercises the optional call back
   function and user data parameters, with =errcode= as the errorcode.  
   #+BEGIN_SRC c  
     cl_int errcode;
     cl_context req_context = clCreateContextFromType (context_props, CL_DEVICE_TYPE_GPU, NULL, NULL, &errcode);
   #+END_SRC


** Information request
   Just as we did with =clGetDeviceInfo= and =clGetPlatformInfo= we can call
   =clGetContextInfo= to retrieve information about the context given the
   parameters in Table \ref{table:6}.  Some of these are additions in OpenCL 1.1

   #+CAPTION: Context information request 
   #+LABEL: table:6
   | Parameter name                               | Output type             | Purpose                                                                                    |
   |----------------------------------------------+-------------------------+--------------------------------------------------------------------------------------------|
   | CL_CONTEXT_NUM_DEVICES                       | cl_uint                 | Returns the number of devices in the context                                               |
   | CL_CONTEXT_DEVICES                           | cl_device_id[]          | Returns the devices in the context                                                         |
   | CL_CONTEXT_PROPERTIES                        | cl_context_properties[] | Returns the property array associated with the context                                     |
   | CL_CONTEXT_REFERENCE_COUNT                   | cl_uint                 | Returns the reference count of the context                                                 |
   | CL_CONTEXT_D3D10_PREFER_SHARED_RESOURCES_KHR | cl_bool                 | Returns whether Direct3D shared resources will be accelerated more than unshared resources |
   |----------------------------------------------+-------------------------+--------------------------------------------------------------------------------------------|

    #+BEGIN_SRC c
      void sb_clPrintContextInfo ( cl_context * context )
      {
	cl_uint num_devices;
	cl_uint ref_count;
	cl_bool d3d_resource;
	cl_int cerror;
      
	/*  This was added in the 1.1 version
	    cerror =  clGetContextInfo (*context, CL_CONTEXT_NUM_DEVICES, sizeof (cl_uint), &num_devices, NULL);
	    if (cerror < 0) {
	    perror ("Error getting context CL_CONTEXT_NUM_DEVICES info\n");
	    exit (EXIT_FAILURE);
	    }
	    printf ("Context number of devices: %d\n", num_devices);
      
	*/
	cerror = clGetContextInfo (*context, CL_CONTEXT_REFERENCE_COUNT, sizeof (cl_uint), &ref_count, NULL);
	if (cerror < 0) {
	  perror ("Error getting context CL_CONTEXT_REFERENCE_COUNT info\n");
	  exit (EXIT_FAILURE);
	}
	printf ("Context reference count: %d\n", ref_count);
      
	/*  This was added in the 1.1 version
	    cerror = clGetContextInfo (*context, CL_CONTEXT_D3D10_PREFER_SHARED_RESOURCES_KHR, sizeof (cl_bool), &d3d_resource, NULL);
	    if (cerror < 0) {
	    perror ("Error getting context CL_CONTEXT_D3D10_PREFER_SHARED_RESOURCES_KHR info\n");
	    exit (EXIT_FAILURE);
	    }
	    printf ("Context d3d exchange: %s\n", d3d_resource ? "true":"false");
	*/
      
      }
    #+END_SRC


* Programs
  Represented by =cl_program= data structure, programs contain multiple kernels
  to be run on your devices.  =cl_program='s may also be queried for information.

  
** Creating 
   Programs are read from files on disk and put into memory for OpenCL to
   access.  Users are required to read the files themselves, as OpenCL does not
   have file reading utilities builtin.  This is the same concept as OpenGL
   shader programs.  There are two was to load a program into memory, by source
   or binary. These functions are for loading OpenCL programs.

   - clCreateProgramWithSource 

     #+BEGIN_SRC c
     cl_program clCreateProgramWithSource (  cl_context context,
                                             cl_uint count,
                                             const char **strings,
                                             const size_t *lengths,
                                             cl_int *errcode_ret)

     #+END_SRC

     - Parameters
       - context

	 Must be a valid OpenCL context.

       - strings

	  An array of count pointers to optionally null-terminated character
         strings that make up the source code.

       - lengths

	  An array with the number of chars in each string (the string
         length). If an element in lengths is zero, its accompanying string is
         null-terminated. If lengths is NULL, all strings in the strings
         argument are considered null-terminated. Any length value passed in
         that is greater than zero excludes the null terminator in its count.

       - errcode_ret
      
	 Returns an appropriate error code. If errcode_ret is NULL, no error
         code is returned.

   
   - clCreateProgramWithBinary 
     #+BEGIN_SRC c
     cl_program clCreateProgramWithBinary (  cl_context context,
                                             cl_uint num_devices,
                                             const cl_device_id *device_list,
                                             const size_t *lengths,
                                             const unsigned char **binaries,
                                             cl_int *binary_status,
                                             cl_int *errcode_ret)

     #+END_SRC

     - Parameters
       - context

	 Must be a valid OpenCL context.
   
       - device_list

	 A pointer to a list of devices that are in context. device_list must be a
	 non-NULL value. The binaries are loaded for devices specified in this list.
   
       - num_devices 

	 The number of devices listed in device_list.  The devices associated with
	 the program object will be the list of devices specified by
	 device_list. The list of devices specified by device_list must be devices
	 associated with context.

       - lengths
   
	 An array of the size in bytes of the program binaries to be loaded for
	 devices specified by device_list.

       - binaries
   
	 An array of pointers to program binaries to be loaded for devices specified
	 by device_list. For each device given by device_list[i], the pointer to the
	 program binary for that device is given by binaries[i] and the length of
	 this corresponding binary is given by lengths[i]. lengths[i] cannot be zero
	 and binaries[i] cannot be a NULL pointer.
   
	 The program binaries specified by binaries contain the bits that describe
	 the program executable that will be run on the device(s) associated with
	 context. The program binary can consist of either or both of
	 device-specific executable(s), and/or implementation-specific intermediate
	 representation (IR) which will be converted to the device-specific
	 executable.

       - binary_status
   
	 Returns whether the program binary for each device specified in device_list
	 was loaded successfully or not. It is an array of num_devices entries and
	 returns CL_SUCCESS in binary_status[i] if binary was successfully loaded
	 for device specified by device_list[i]; otherwise returns CL_INVALID_VALUE
	 if lengths[i] is zero or if binaries[i] is a NULL value or
	 CL_INVALID_BINARY in binary_status[i] if program binary is not a valid
	 binary for the specified device. If binary_status is NULL, it is ignored.

       - errcode_ret
   
	 Returns an appropriate error code. If errcode_ret is NULL, no error code is
	 returned.
  					     
	 
   The following code is mostly from the book [fn:1], and has been placed into
   two functions.  It seems to be the best and most straight forward way of
   reading the source code of a program, so why reinvent the wheel.  The only
   lacking thing is error checking on the program.  Hope to be adding the
   compilation error checking and OpenCL version checking portion to these
   functions which will be more involved and at a later time.  This is to
   reflect best practice I have run into with OpenGL shader programs which are
   loaded in the same fashion.

   #+BEGIN_SRC c
     int sb_clReadSourceProgramFromDisk ( char * file_name, char * program_buffer, int *program_size )
     {
       long file_size;
       FILE file_handle;
       file_handle = fopen (file_name, "r");
       if ( NULL == file_handle ) {
         perror ("Error opening file %s\n", file_name);
         return -1;
       }
     
       fseek (file_handle, 0, SEEK_END);
       file_size = ftell (file_handle);
       rewind (file_handle);
       
       program_buffer = (char *) malloc (file_size + 1);
       program_buffer [file_size] = '\0';
       fread (program_buffer, sizeof (char), file_size, file_handle);
       fclose (file_handle);
       *program_size = file_size;
     }
     
     cl_program sb_clCreateProgramFromSource (char * program_buffer, int program_size, cl_context context )
     {
       cl_program program;
       program = clCreateProgramWithSource (context, 1, (const char **) program_buffer, program_size, &err);
     }
   #+END_SRC
   
   
** Compiling 
   After loading the program source code it must be compiled.  
   
   Here are some of the build options available.  See the [fn:2]
   specification for more information.

   | Option                        | Description                                                                   |
   |-------------------------------+-------------------------------------------------------------------------------|
   | -D =name=                     | Predefine name as a macro, with definition 1                                  |
   | -D =name\=definition=         | set the contents of a definition                                              |
   | -I =dir=                      | add the directory =dir= to the list of directories to search for header files |
   | -cl-single-precision-constant | Tread double precision floating point constant as a single precision constant |
   | -cl-denorms-are-zero          | See [fn:2]                                                                    |
   | -cl-opt-disable               | disable all optimization's, default all optimization's are used.              |
   |-------------------------------+-------------------------------------------------------------------------------|

   #+BEGIN_SRC c

cl_int clBuildProgram (	cl_program program,
 	cl_uint num_devices,
 	const cl_device_id *device_list,
 	const char *options,
 	void (*pfn_notify)(cl_program, void *user_data),
 	void *user_data)

   #+END_SRC

   - program
   
     The program object

   - device_list

     A pointer to a list of devices that are in program. If
     device_list is NULL value, the program executable is built for
     all devices associated with program for which a source or binary
     has been loaded. If device_list is a non-NULL value, the program
     executable is built for devices specified in this list for which
     a source or binary has been loaded.

   - num_devices

     The number of devices listed in device_list.

   - options

     A pointer to a string that describes the build options to be used
     for building the program executable. The list of supported
     options is described in "Build Options" below.

   - pfn_notify

     A function pointer to a notification routine. The notification
     routine is a callback function that an application can register
     and which will be called when the program executable has been
     built (successfully or unsuccessfully). If pfn_notify is not
     NULL, clBuildProgram does not need to wait for the build to
     complete and can return immediately. If pfn_notify is NULL,
     clBuildProgram does not return until the build has
     completed. This callback function may be called asynchronously by
     the OpenCL implementation. It is the application's responsibility
     to ensure that the callback function is thread-safe.

   - user_data

     Passed as an argument when pfn_notify is called. user_data can be
     NULL.





** Information request
   
   You may then access information about the program by using the
   =clGetProgramInfo= function.
#+BEGIN_SRC c
clGetProgramInfo(cl_program program, cl_program_info param_name,
    size_t param_value_size, void *param_value,
    size_t *param_value_size_ret
#+END_SRC

   =cl_program_info= is an enum that identifies the following data
   queries.

   | Parameter name             | Output type     | Purpose                                                             |
   |----------------------------+-----------------+---------------------------------------------------------------------|
   | CL_PROGRAM_CONTEXT         | cl_context      | Returns the context used to create the program                      |
   | CL_PROGRAM_DEVICES         | cl_device_id[]  | Returns the devices targeted by the program                         |
   | CL_PROGRAM_NUM_DEVICES     | cl_uint         | Returns the number of devices targeted by the program               |
   | CL_PROGRAM_SOURCE          | char[]          | Returns the program’s source code concatenated into a single string |
   | CL_PROGRAM_BINARIES        | unsigned_char** | Returns the array of binary buffers associated with the program     |
   | CL_PROGRAM_BINARY_SIZES    | size_t[]        | Returns the size of each of the program’s binary buffers            |
   | CL_PROGRAM_REFERENCE_COUNT | cl_uint         | Returns the program’s reference count                               |
   |----------------------------+-----------------+---------------------------------------------------------------------|
   
   You may then use the =clGetProgramBuildInfo= to obtain information
   abount the build proccess of a program.

#+BEGIN_SRC c
clGetProgramBuildInfo(cl_program program,
    cl_device_id device,
    cl_program_build_info param_name,
    size_t param_value_size, void *param_value,
    size_t *param_value_size_ret)
#+END_SRC

   =cl_program_build_info= is a enum type for the following
   information

   | Parameter name           | Output type     | Purpose                                                          |
   |--------------------------+-----------------+------------------------------------------------------------------|
   | CL_PROGRAM_BUILD_STATUS  | cl_build_status | Identifies whether the build succeeded, failed, or is continuing |
   | CL_PROGRAM_BUILD_OPTIONS | char[]          | Returns the options used to configure the build                  |
   | CL_PROGRAM_BUILD_LOG     | char[]          | Returns the build log—the compiler’s output                      |
   |--------------------------+-----------------+------------------------------------------------------------------|




* Kernels

  Are the packaged items of programs.  These are then dispensed around
  to available command queues.

  
** Creating
   
   To create a kernel for every function in your kernel use the
   =clCreateKernelsInProgram= function.  This will creates multiple
   kernels to use.  Like the previous function you can call this
   twice to obtain information about how much memory to allocate for
   the kernels.

#+BEGIN_SRC c
clCreateKernelsInProgram(cl_program program, cl_uint num_kernels,
    cl_kernel *kernels, cl_uint *num_kernels_ret);
#+END_SRC

   To create a single kernel for a known function name use the
   =clCreateKernel= function.  You must know the name of the function
   to use this.

#+BEGIN_SRC c
  clCreateKernel(cl_program program, const char *kernel_name, cl_int *error)
#+END_SRC

** Information request
   
   You may query a kernel for information about what function it
   represents and what program it belongs to using the
   =clGetKernelInfo= function.

#+BEGIN_SRC c
  clGetKernelInfo(cl_kernel kernel, cl_kernel_info param_name,
                  size_t param_value_size, 
                  void *param_value, 
                  size_t *param_value_size_ret)
#+END_SRC

   The =cl_kernel_info= enum may use the following values.

| Parameter name            | Output type | Purpose                                                                            |
|---------------------------+-------------+------------------------------------------------------------------------------------|
| CL_KERNEL_FUNCTION_NAME   | char[]      | Returns the name of the function from which the kernel was formed                  |
| CL_KERNEL_NUM_ARGS        | cl_uint     | Returns the number of input arguments accepted by the kernel’s associated function |
| CL_KERNEL_REFERENCE_COUNT | cl_uint     | Returns the number of times the kernel has been referenced in code                 |
| CL_KERNEL_CONTEXT         | cl_context  | Returns the context associated with the kernel                                     |
| CL_KERNEL_PROGRAM         | cl_program  | Returns the program from which the kernel was created                              |
|---------------------------+-------------+------------------------------------------------------------------------------------|
    

* Command Queues

  These are the lines that pump kernels and data to devices.  Used to
  associate devices with proccessing capabilities, these recieve
  kernels and execute them on their associated devices.

  
** Creating

   Command queues are represented by the =cl_command_queue= struct.
   They do not have an information function and only one function
   creates new ones, =clCreateCommandQueue=.  This will return the
   cl_command_queue structure.
#+BEGIN_SRC c
  cl_command_queue clCreateCommandQueue(cl_context context, cl_device_id device,
                       cl_command_queue_properties properties, 
                       cl_int *err)
#+END_SRC

   =cl_command_queue_properties= may have the following value

  - CL_QUEUE_PROFILING_ENABLE
    Enable profiling events 

  - CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE  
    Enables out of order
   
   You then increment and decrement the reference count just like a
    context. =clRetainCommandQueue= increments,
    =clReleaseCommandQueue= decrements.

** Enqueuing kernel execution commands

   One of example of enqueuing kernels to queues is the
   =clEnqueueTask=
   #+BEGIN_SRC c
     clEnqueueTask(cl_command_queue queue, 
                   cl_kernel kernel,
                   cl_uint num_events, 
                   const cl_event *wait_list, 
                   cl_event *event);
   #+END_SRC

   This will then go to the device when its time is the queue comes up.


* Data to and From Kernels

** Kernel Arguments

   #+BEGIN_SRC c
     cl_int clSetKernelArg ( cl_kernel kernel,
			     cl_uint arg_index,
			     size_t arg_size,
			     const void *arg_value);
   #+END_SRC

   See the [[https://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clSetKernelArg.html][sdk_doc]] for access to the complete explanation,  in short
   they are.

   - cl_kernel:kernel

     Kernel to pass the arguments too.

   - cl_uint:arg_index

     Index of argument passed to the kernel this is going to.
     ex =my_kernel_func (float arg0, int arg1)=

   - size_t:arg_size

     The allocated size of the object being passed.  Cannot exceed
     CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE

   - const void :*arg_value

     Pointer to data being passed


* Platform Specific Notes

** Intel

   The Intel development package is found at [[http://software.intel.com/en-us/vcsource/tools/opencl-sdk][Intel OpenCL sdk]]. Read
   the installation instructions for your platform.  

   It does not contain an Ubuntu package, use the instructions at [[http://mhr3.blogspot.com/2011/05/opencl-on-ubuntu.html
 ][Intel sdk Ubuntu]] to convert it over.

   - Install the 'rpm', 'alien' and 'libnuma1' packages
   - Convert the rpm to a dpkg =fakeroot alien --to-dev <intel-sdk>=
   - Install the deb, =sudo dpkg -i <intel-sdk.deb>=
   - link the opencl lib to /usr/lib =sudo ln -s /usr/lib64/libOpenCL.so /usr/lib/libOpenCL.so=
   - run ldconfig =sudo ldconfig=
     

* Footnotes

[fn:1] OpenCL in Action: How to accelerate graphics and computation. 
  By Matthew Scarpino; http://www.manning.com/scarpino2/

[fn:2] OpenCL 1.0 reference pages: http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/
 
