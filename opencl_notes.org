#+OPTIONS: ^:{}

James A. Feister, OpenCL Notebook

* Intro
  This is my notebook for OpenCL.  It contains a collection of notes
  from various resources.  Some of these are taken verbatim from the
  texts so this should not be taken as my own work.
  
  References include:
  - OpenCL in action[fn:1]: How to Accelerate Graphics and Computation
  - OpenCL 1.0 Reference Pages [fn:2]
    
* About OpenCL
  OpenCL allows for utilizing different VECTOR processing units while
  remaining manufacture agnostic.  You can use Intel, AMD, NVIDIA, or
  other hardware vector processing capabilities without having to know
  their specific implementations.
  
  Typical applications of vector processing for the purpose of OpenCL
  are broken into one of 3 categories.
  - Physical or Geometric: Vectors that represent Magnitude and
  Direction
  - Mathematical vector: Ordered one dimensional collection of
    elements
  - Computational: Data structure that contains multiple elements of
  the same data type.
* Data Structures
  There are six basic data structures of OpenCL

  1) Platforms: Identifies a Vendors implementation

  2) Devices
     
  3) Contexts
     
  4) Programs
     
  5) Kernels
     
  6) Command Queues
     
* Primitive Data Types
  
  Table \ref{table:1} shows a list of all primitive OpenCL data types found in CL/cl_platform.h

#+CAPTION: OpenCL Primitive Data types
#+LABEL: table:1  
  | Scalar Data Type | Bit Width | Purpose                               |
  |------------------+-----------+---------------------------------------|
  | cl_char          |         8 | Signed two's Complement integer       |
  | cl_uchar         |         8 | unSigned two's complement integer     |
  | cl_short         |        16 | Signed two's Complement integer       |
  | cl_ushort        |        16 | unSigned two's Complement integer     |
  | cl_int           |        32 | Signed two's Complement integer       |
  | cl_uint          |        32 | unSigned two's Complement integer     |
  | cl_long          |        64 | Signed two's Complement integer       |
  | cl_ulong         |        64 | unSigned two's Complement integer     |
  | cl_half          |        16 | Half precision floating point value |
  | cl_float         |        32 | Single precision floating point value |
  | cl_double        |        64 | Double precision floating point value |
  |------------------+-----------+---------------------------------------|
  
* Platform Data Structure
  
  type: cl_platform_id - represents a platform of a OpenCL
  implementation
  
  For example if you have a NVIDIA video card and Intel CPU, you would
  require two platforms, one to access the NVIDIA CUDA video card
  platform and one to access the Intel SMD

** Obtaining available platforms
   Platforms are only available if you have the appropriate vendor SDK
   installed on your system.
   
   Function def: cl_int clGetPlatformIDs (cl_uint num_entries,
   cl_platform_id * platforms, cl_uint * num_platforms);
   
   The clGetPlatformIDs function allows for you to query the number of
   available platforms.
   
   #+begin_src cpp
  cl_int num_platforms; clGetPlatformIDs (1, NULL, &num_platforms);
   #+end_src
   
   You then can use it to obtain handles to those platforms.  Which
   allow you to query for information on them.
   
   #+begin_src cpp
  cl_platform_id platforms = (platforms *) malloc ( sizeof
  (cl_platform_id) * num_platforms ); clGetPlatformIDs (num_platforms,
  platforms, NULL);
   #+end_src
   
   You now have handles to all platforms available on your system.
   
   
** Obtaining platform information
   Table \ref{table:2} Shows all information about a platform may be queried.
   
#+CAPTION: Platform query information
#+LABEL:  table:2
   | Parameter name         | Purpose                                          |
   |------------------------+--------------------------------------------------|
   | CL_PLATFORM_NAME       | Name of the platform                             |
   | CL_PLATFORM_VENDOR     | Vendor of the platform                           |
   | CL_PLATFORM_VERSION    | Supported  OpenCL version                        |
   | CL_PLATFORM_PROFILE    | FULL_PROFILE or EMBEDDED_PROFILE OpenCL Standard |
   | CL_PLATFORM_EXTENSIONS | List of supported extensions                     |
   |------------------------+--------------------------------------------------|
   
   The function clGetPlatformInfo function is used to query for this
   information.
   
   #+begin_src c
  cl_int clGetPlatformInfo(cl_platform_id platform, cl_platform_info
  param_name, size_t param_value_size, void *param_value, size_t
  *param_value_size_ret)
   #+end_src
   
   The following user created support functions will query for all
   platforms parameter values. Pass the platform to
   sb_clPrintPlatformInfo to print all platform values.
   
   #+begin_src c
  void sb_clPrintPlatformInfo ( cl_platform_id * platform ) 
  {
    printf ("Platform Info\n");
  
    printf ("\tName: ");
    sb_clPrintPlatformExtension ( platform, CL_PLATFORM_NAME );
    printf ("\n");
  
    printf ("\tVendor: ");
    sb_clPrintPlatformExtension (  platform, CL_PLATFORM_VENDOR );
    printf ("\n");
  
    printf ("\tVersion: ");
    sb_clPrintPlatformExtension (  platform, CL_PLATFORM_VERSION );
    printf ("\n");
  
    printf ("\tProfile: ");
    sb_clPrintPlatformExtension (  platform, CL_PLATFORM_PROFILE );
    printf ("\n");
  
    printf ("\tExtensions: ");
    sb_clPrintPlatformExtension (  platform, CL_PLATFORM_EXTENSIONS );
    printf ("\n");
  }
  
  void sb_clPrintPlatformExtension ( cl_platform_id * platform, cl_int extension ) 
  {
    cl_char * ext_data;
    size_t param_size;
    cl_int ret;
  
    ret = clGetPlatformInfo (*platform, extension, 0, NULL, &param_size);
    if ( ret < 0 ) {
      perror ("Couldn't read extension data.");
      exit (EXIT_FAILURE);
    }
    ext_data = (cl_char*)malloc(param_size+1);
    ext_data[param_size] = '\0';
    ret = clGetPlatformInfo (*platform, extension, param_size, ext_data, NULL);
    printf ("%s", ext_data);
    free (ext_data);
  }
   #+end_src
   
   
** Obtaining Devices
   Devices associated with a specific platform can be queried by the
   following function.
   
   #+begin_src c
  cl_int clGetDeviceIDs(cl_platform_id platform,
      cl_device_type device_type, cl_uint num_entries,
      cl_device_id *devices, cl_uint *num_devices)
   #+end_src
   
   Just like the you did with the clGetPlatformIDs function you query a
   platform for the number of devices available of a specific
   type. Then allocate and request device types for that number of
   devices specified.
   
   Table \ref{table:3} shows available devices to query for are in the following table.
   
#+CAPTION: Available device types
#+LABEL: table:3
   | Device type                | Description                  |
   |----------------------------+------------------------------|
   | CL_DEVICE_TYPE_ALL         | All platform devices         |
   | CL_DEVICE_TYPE_DEFAULT     | All platform default devices |
   | CL_DEVICE_TYPE_CPU         | Host processor               |
   | CL_DEVICE_TYPE_GPU         | Device containing a GPU        |
   | CL_DEVICE_TYPE_ACCELERATOR | External accelerator device  |
   |----------------------------+------------------------------|
   
   The following function demonstrates the query for all specific devices on a
   platform.
   
   #+begin_src c
void sb_clPrintPlatformDevices ( cl_platform_id * platform )
{
  cl_uint num_devices;

  //  Get CL_DEVICE_TYPE_ALL for the platform
  clGetDeviceIDs (*platform, CL_DEVICE_TYPE_ALL, 1, NULL, &num_devices);
  printf ("ALL platform devices: %d\n", num_devices);

  // Get  CL_DEVICE_TYPE_DEFAULT for the platform
  clGetDeviceIDs (*platform, CL_DEVICE_TYPE_DEFAULT, 1, NULL, &num_devices);
  printf ("DEFAULT platform devices: %d\n", num_devices);

  // Get  CL_DEVICE_TYPE_CPU for the platform
  clGetDeviceIDs (*platform,  CL_DEVICE_TYPE_CPU, 1, NULL, &num_devices);
  printf ("CPU platform devices: %d\n", num_devices);

  // Get  CL_DEVICE_TYPE_GPU for the platform
  clGetDeviceIDs (*platform,  CL_DEVICE_TYPE_GPU, 1, NULL, &num_devices);
  printf ("GPU platform devices: %d\n", num_devices);

  // Get  CL_DEVICE_TYPE_ACCELERATOR for the platform
  clGetDeviceIDs (*platform,  CL_DEVICE_TYPE_ACCELERATOR, 1, NULL, &num_devices);
  printf ("ACCELERATOR platform devices: %d\n", num_devices);
}
   #+end_src
   
** TODO Obtaining Device Info
   This function does not work as the last, it seems to not return
   the size of the data structure to allocate against it.  Will
   revisit in the future to resolve the shortcuts in this function.
   
   Just as with the platforms you can query devices for their information
   as well.  Table \ref{table:4} list the available fields for query.
   
#+CAPTION: Device query information
#+LABEL: table:4
   | Parameter name               | Output Type | Purpose                                     |
   |------------------------------+-------------+---------------------------------------------|
   | CL_DEVICE_NAME               | char[]      | Name of device                              |
   | CL_DEVICE_VENDOR             | char[]      | Device vendor                               |
   | CL_DEVICE_EXTENSIONS         | char[]      | Supported OpenCL extensions                 |
   | CL_DEVICE_GLOBAL_MEM_SIZE    | cl_ulong    | Size of devices global memory               |
   | CL_DEVICE_ADDRESS_BITS       | cl_uint     | Size of devices address space               |
   | CL_DEVICE_AVAILABLE          | cl_bool     | Is the device available                     |
   | CL_DEVICE_COMPILER_AVAILABLE | cl_bool     | Does the implementation provide a compiler? |
   |------------------------------+-------------+---------------------------------------------|
   
   The clGetDeviceInfo is used to query for device information
   
   #+begin_src c
  cl_int clGetDeviceInfo (cl_device_id device, cl_device_info
  param_name, size_t param_value_size, void *param_value, size_t
  *param_value_size_ret);
   #+end_src
   
   This is a helper function to do the query for these parameters.
   
   #+begin_src c
void sb_clPrintPlatformDeviceInfo ( cl_device_id * device )
{

  size_t   qstring_len = 2048;
  cl_ulong qmemory_size = 0;
  cl_uint  qaddress_space = 0;
  cl_bool  qdevice_available = false;
  cl_bool  qdevice_compiler  = false;
  cl_char * qstring = (cl_char *) malloc (qstring_len+1);

  qstring[qstring_len] = '\0';

  clGetDeviceInfo ( *device, CL_DEVICE_NAME, qstring_len, qstring, NULL);
  printf ("Vendor Device Name: %s\n", qstring);

  clGetDeviceInfo ( *device, CL_DEVICE_VENDOR, qstring_len, qstring, NULL);
  printf ("Vendor Name: %s\n", qstring);

  clGetDeviceInfo ( *device, CL_DEVICE_EXTENSIONS, qstring_len, qstring, NULL);
  printf ("Device Extensions: %s\n", qstring);

  clGetDeviceInfo ( *device, CL_DEVICE_GLOBAL_MEM_SIZE, sizeof (cl_ulong), &qmemory_size, NULL);
  printf ("Device Address Space Size: %d\n", qmemory_size);

  clGetDeviceInfo ( *device, CL_DEVICE_ADDRESS_BITS, sizeof (cl_uint), &qaddress_space, NULL);
  printf ("Device Address Bits: %d\n", qaddress_space);

  clGetDeviceInfo ( *device, CL_DEVICE_AVAILABLE, sizeof (cl_bool), &qdevice_available, NULL);
  printf ("Device Available: %s\n", qdevice_available ? "true":"false");

  clGetDeviceInfo ( *device, CL_DEVICE_COMPILER_AVAILABLE, sizeof (cl_bool), &qdevice_compiler, NULL);
  printf ("Device Compiler: %s\n", qdevice_compiler ? "true":"false");
}
   #+end_src
   
   There are plenty more things to query for as per the standard.
   http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clGetDeviceInfo.html

* Contexts

  Contexts are created to manage devices from the same platform
  selected to work together.  You use the context to create command
  queues for sending kernels to devices.

  An application may use multiple contexts to utilize multiple
  platforms for all devices of each platform.

** Creating contexts

   To populate the cl_context data structure you can grab contexts to selected
   devices or devices of a specific type.

   #+BEGIN_SRC c
     cl_context clCreateContext (const cl_context_properties *properties, 
                                 cl_uint num_devices, const cl_device_id *devices, 
                                 (void CL_CALLBACK *pfn_notify) (const char *errinfo, 
                                                                 const void *private_info, 
                                                                 size_t cb, void *user_data), 
                                 void *user_data, cl_int *errcode_ret);
     
     cl_context clCreateContextFromType (const cl_context_properties *properties,
                                         cl_device_type device_type,
                                         (void CL_CALLBACK *pfn_notify) (const char *errinfo, 
                                                                         const void *private_info, 
                                                                         size_t cb, void *user_data), 
                                         void *user_data, cl_int *errcode_ret);
   #+END_SRC

   Table \ref{table:3} shows all the device types you are able to request.
   =clCreateContext= is used to request user specific devices while
   =clCreateContextFromType= performs a blanket request from a context of the
   specified type.

   Section 2.4.1 creating contexts in the book [fn:1] has a better explanation
   of this process.  I will try my best here.

** Specify the Context =*properties= array

  Table \ref{table:5} shows the available properties you can query for in a
  context. 

  #+CAPTION: Context Property Parameters
  #+LABEL: table:5
  | Property name               | Property value   | Meaning                                                        |
  |-----------------------------+------------------+----------------------------------------------------------------|
  | CL_CONTEXT_PLATFORM         | cl_context_id    | Associates the context with the given platform                 |
  | CL_CONTEXT_D3D10_DEVICE_KHR | ID3D10Device*    | Associates the context with the Direct3D device                |
  | CL_GL_CONTEXT_KHR           | OS-Dependent     | Identifies an OpenGL context                                   |
  | CL_EGL_DISPLAY_KHR          | EGLDisplay       | Displays the OpenGL-ES context on embedded devices             |
  | CL_GLX_DISPLAY_KHR          | GLXContext       | Displays the OpenGL context on Linux                           |
  | CL_WGL_HDC_KHR              | HDC              | Serves as the device context for the OpenGL context on Windows |
  | CL_CGL_SHAREGROUP_KHR       | CGLShareGroupObj | Serves as the share group for the OpenGL context on Mac OS     |
  |-----------------------------+------------------+----------------------------------------------------------------|

  These are used as a *NULL* or *0* terminated array. For example

  #+BEGIN_SRC c  
    cl_context_properties r_context_properties[] = {
      CL_CONTEXT_PLATFORM, (cl_context_properties)platforms[0],
      CL_GL_CONTEXT, (cl_context_properties) glxGetCurrentContext(),
      CL_GLX_DISPLAY_KHR, (cl_context_properties) glxGetCurrentDisplay(),
      0};
  #+END_SRC

  Will query for a context of =platform[0]=, associate the current =GLXContext=
  returned from =glxGetCurrentContext()=, associate the current =Display=
  returned from =glxGetCurrentDisplay()=, and then the last field terminates
  the array with a 0.

  
** Return function

   The =void CL_CALLBACK *notify_func= is a callback function called when an
   error occurs.  This may also be =NULL= to unset its use.

** =*user_data=
   Supplied by the user for use in the context.  On an error this will also be passed to the
   registered callback function.  Its type can be anything from char to int or NULL.

** =*errcode_ret=
   Is the error code returned from creating the context.  

   * CL_INVALID_PLATFORM 'if properties is NULL and no platform could be
     selected or if platform value specified in properties is not a valid
     platform.'

   * CL_INVALID_VALUE 'if context property name in properties is not a
     supported property name; if devices is NULL; if num_devices is equal to
     zero; or if pfn_notify is NULL but user_data is not NULL.'

   * CL_INVALID_DEVICE 'if devices contains an invalid device or are not
     associated with the specified platform.'

   * CL_DEVICE_NOT_AVAILABLE ' if a device in devices is currently not
     available even though the device was returned by clGetDeviceIDs.'

   * CL_OUT_OF_HOST_MEMORY 'if there is a failure to allocate resources
     required by the OpenCL implementation on the host.'

** Context request
   After reading the above and the book [fn:1] we come up with the following
   example piece of code.  This will use the =context_props= context type
   request array from before with a type of GPU and exercises the optional call back
   function and user data parameters, with =errcode= as the errorcode.  
   #+BEGIN_SRC c  
     cl_int errcode;
     cl_context req_context = clCreateContextFromType (context_props, CL_DEVICE_TYPE_GPU, NULL, NULL, &errcode);
   #+END_SRC


** Context info request
   Just as we did with =clGetDeviceInfo= and =clGetPlatformInfo= we can call
   =clGetContextInfo= to retrieve information about the context given the
   parameters in Table \ref{table:6}.  Some of these are additions in OpenCL 1.1

   #+CAPTION: Context information request 
   #+LABEL: table:6
   | Parameter name                               | Output type             | Purpose                                                                                    |
   |----------------------------------------------+-------------------------+--------------------------------------------------------------------------------------------|
   | CL_CONTEXT_NUM_DEVICES                       | cl_uint                 | Returns the number of devices in the context                                               |
   | CL_CONTEXT_DEVICES                           | cl_device_id[]          | Returns the devices in the context                                                         |
   | CL_CONTEXT_PROPERTIES                        | cl_context_properties[] | Returns the property array associated with the context                                     |
   | CL_CONTEXT_REFERENCE_COUNT                   | cl_uint                 | Returns the reference count of the context                                                 |
   | CL_CONTEXT_D3D10_PREFER_SHARED_RESOURCES_KHR | cl_bool                 | Returns whether Direct3D shared resources will be accelerated more than unshared resources |
   |----------------------------------------------+-------------------------+--------------------------------------------------------------------------------------------|

    #+BEGIN_SRC c
      void sb_clPrintContextInfo ( cl_context * context )
      {
	cl_uint num_devices;
	cl_uint ref_count;
	cl_bool d3d_resource;
	cl_int cerror;
      
	/*  This was added in the 1.1 version
	    cerror =  clGetContextInfo (*context, CL_CONTEXT_NUM_DEVICES, sizeof (cl_uint), &num_devices, NULL);
	    if (cerror < 0) {
	    perror ("Error getting context CL_CONTEXT_NUM_DEVICES info\n");
	    exit (EXIT_FAILURE);
	    }
	    printf ("Context number of devices: %d\n", num_devices);
      
	*/
	cerror = clGetContextInfo (*context, CL_CONTEXT_REFERENCE_COUNT, sizeof (cl_uint), &ref_count, NULL);
	if (cerror < 0) {
	  perror ("Error getting context CL_CONTEXT_REFERENCE_COUNT info\n");
	  exit (EXIT_FAILURE);
	}
	printf ("Context reference count: %d\n", ref_count);
      
	/*  This was added in the 1.1 version
	    cerror = clGetContextInfo (*context, CL_CONTEXT_D3D10_PREFER_SHARED_RESOURCES_KHR, sizeof (cl_bool), &d3d_resource, NULL);
	    if (cerror < 0) {
	    perror ("Error getting context CL_CONTEXT_D3D10_PREFER_SHARED_RESOURCES_KHR info\n");
	    exit (EXIT_FAILURE);
	    }
	    printf ("Context d3d exchange: %s\n", d3d_resource ? "true":"false");
	*/
      
      }
    #+END_SRC


* Programs
  Represented by =cl_program= data structure, programs contain multiple
  kernels to be run on your devices.

** Creating

* Footnotes

[fn:1] OpenCL in Action: How to accelerate graphics and computation. 
  By Matthew Scarpino; http://www.manning.com/scarpino2/

[fn:2] OpenCL 1.0 reference pages: http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/
 
